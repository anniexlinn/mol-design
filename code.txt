# -*- coding: utf-8 -*-
"""final project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13FawP6f896m5k5daXkng0xvIpuYi-Ruw
"""

!pip install rdkit PyTDC wget pandas-flavor
!pip install git+https://github.com/bp-kelley/descriptastorus
!pip install rdkit PyTDC wget selfies

from tqdm import trange
from tqdm.auto import tqdm
import random
import os
import yaml
from typing import List, Set
from functools import total_ordering
import numpy as np
import pandas as pd
import joblib
import wget

from rdkit import Chem, rdBase
from rdkit.Chem import MolFromSmiles as smi2mol
from rdkit.Chem import MolToSmiles as mol2smi
from rdkit.Chem import AllChem
from rdkit.Chem.rdchem import Mol
from rdkit.Chem import rdFingerprintGenerator
from rdkit import RDLogger
RDLogger.DisableLog('rdApp.*')

from sklearn.neural_network import MLPRegressor
from sklearn.svm import SVR
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import accuracy_score, precision_score, recall_score
import tdc
from tdc import Evaluator
from tdc import Oracle
from tdc.generation import MolGen
from tdc.chem_utils import MolConvert
from tdc import Evaluator
int_div = Evaluator(name = 'Diversity')
from xgboost import XGBRegressor
from rdkit import DataStructs
from sklearn.datasets import load_wine
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split

import selfies
from selfies import encoder, decoder

wget.download("https://raw.githubusercontent.com/wenhao-gao/24IAP_ml4moldesign/main/project/initial.csv")
data = pd.read_csv('initial.csv')
data

converter = MolConvert(src = 'SMILES', dst = 'RDKit2D')
X = converter(data['smiles'].to_list())
y = data['score'].to_numpy()


models = {
    'RandomForest': RandomForestRegressor(n_estimators=50, max_depth=50, random_state=0),
    'MLP': MLPRegressor(random_state=0),
    'SVR': SVR(),
    'XGB': XGBRegressor()
}

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

for regressor_name, regressor in models.items():
    regressor.fit(X_train, y_train)  # training
    y_pred = regressor.predict(X_test)  # predictions on the test set
    mae = mean_absolute_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    print(f"{regressor_name} - MAE: {mae:.2f}, R2: {r2:.2f}")

regr = RandomForestRegressor(n_estimators=50, max_depth=50, random_state=0)
regr.fit(X_train, y_train)

wget.download("https://raw.githubusercontent.com/wenhao-gao/24IAP_ml4moldesign/main/project/mutate.py")
wget.download("https://raw.githubusercontent.com/wenhao-gao/24IAP_ml4moldesign/main/project/crossover.py")

import crossover
import mutate as mu

def func(smi):
    if type(smi) == str:
        return regr.predict(converter([smi]))
    elif type(smi) == list:
        return regr.predict(converter(smi))
    else:
        return 0

class OracleStorage:
    def __init__(self, args=None, mol_buffer={}):
        self.name = None
        self.evaluator = None
        self.task_label = None
        if args is None:
            self.max_oracle_calls = 10000
            self.freq_log = 100
        else:
            self.args = args
            self.max_oracle_calls = args.max_oracle_calls
            self.freq_log = args.freq_log
        self.mol_buffer = mol_buffer
        self.sa_scorer = tdc.Oracle(name = 'SA')
        self.diversity_evaluator = tdc.Evaluator(name = 'Diversity')
        self.last_log = 0

    @property
    def budget(self):
        return self.max_oracle_calls

    def assign_evaluator(self, evaluator):
        self.evaluator = evaluator

    def sort_buffer(self):
        self.mol_buffer = dict(sorted(self.mol_buffer.items(), key=lambda kv: kv[1][0], reverse=True))

    def save_result(self, suffix=None):

        if suffix is None:
            output_file_path = os.path.join(self.args.output_dir, 'results.yaml')
        else:
            output_file_path = os.path.join(self.args.output_dir, 'results_' + suffix + '.yaml')

        self.sort_buffer()
        with open(output_file_path, 'w') as f:
            yaml.dump(self.mol_buffer, f, sort_keys=False)

    def __len__(self):
        return len(self.mol_buffer)

    def score_smi(self, smi):
        if len(self.mol_buffer) > self.max_oracle_calls:
            return 0
        if smi is None:
            return 0
        mol = Chem.MolFromSmiles(smi)
        if mol is None or len(smi) == 0:
            return 0
        else:
            smi = Chem.MolToSmiles(mol)
            if smi in self.mol_buffer:
                pass
            else:
                self.mol_buffer[smi] = [float(self.evaluator(smi)), len(self.mol_buffer)+1]
            return self.mol_buffer[smi][0]

    def __call__(self, smiles_lst):
        if type(smiles_lst) == list:
            score_list = []
            for smi in smiles_lst:
                score_list.append(self.score_smi(smi))
                if len(self.mol_buffer) % self.freq_log == 0 and len(self.mol_buffer) > self.last_log:
                    self.sort_buffer()
                    self.last_log = len(self.mol_buffer)
                    # self.save_result(self.task_label)
        else:
            score_list = self.score_smi(smiles_lst)
            if len(self.mol_buffer) % self.freq_log == 0 and len(self.mol_buffer) > self.last_log:
                self.sort_buffer()
                self.last_log = len(self.mol_buffer)
                # self.save_result(self.task_label)
        return score_list

    @property
    def finish(self):
        return len(self.mol_buffer) >= self.max_oracle_calls

from selfies import decoder, get_semantic_robust_alphabet

def get_ECFP4(mol):
    return AllChem.GetMorganFingerprint(mol, 2)


def sanitize_smiles(smi):
    try:
        mol = smi2mol(smi, sanitize=True)
        smi_canon = mol2smi(mol, isomericSmiles=False, canonical=True)
        return (mol, smi_canon, True)
    except:
        return (None, None, False)

def mutate_selfie_diverse(selfie, max_molecules_len, mutation_prob=0.99, write_fail_cases=False):
    """
    mutate a given selfie with diversity-promoting mutations

    args:
        selfie (str): input selfie string
        max_molecules_len (int): max length of the molecules
        mutation_prob (float): probability of mutation
        write_fail_cases (bool): whether to write fail cases to a file

    returns:
        mutated_selfie (str): mutated selfie string
        smiles_canon (str): canonicalized SMILES of the mutated selfie
    """
    valid = False
    fail_counter = 0
    chars_selfie = get_selfie_chars(selfie)

    while not valid:
        fail_counter += 1

        alphabet = list(get_semantic_robust_alphabet())  # 34 SELFIE characters

        choice_ls = [1, 2, 3]  # 1=insert; 2=replace; 3=delete
        random_choice = np.random.choice(choice_ls, 1)[0]

        # introduce diversity-promoting mutations with a certain probability
        if random.random() < mutation_prob:
            random_mut_choice = np.random.choice([1, 2], 1)[0]
            if random_mut_choice == 1:
                # add a random structure at a random location
                random_index = np.random.randint(len(chars_selfie) + 1)
                random_character = np.random.choice(alphabet, size=1)[0]
                selfie_mutated_chars = chars_selfie[:random_index] + [random_character] + chars_selfie[random_index:]
            else:
                # replace a random character
                random_index = np.random.randint(len(chars_selfie))
                random_character = np.random.choice(alphabet, size=1)[0]
                selfie_mutated_chars = chars_selfie[:random_index] + [random_character] + chars_selfie[random_index+1:]
        else:
            # perform the original mutations
            if random_choice == 1:
                random_index = np.random.randint(len(chars_selfie) + 1)
                random_character = np.random.choice(alphabet, size=1)[0]
                selfie_mutated_chars = chars_selfie[:random_index] + [random_character] + chars_selfie[random_index:]
            elif random_choice == 2:
                random_index = np.random.randint(len(chars_selfie))
                random_character = np.random.choice(alphabet, size=1)[0]
                if random_index == 0:
                    selfie_mutated_chars = [random_character] + chars_selfie[random_index + 1:]
                else:
                    selfie_mutated_chars = chars_selfie[:random_index] + [random_character] + chars_selfie[random_index + 1:]
            elif random_choice == 3:
                random_index = np.random.randint(len(chars_selfie))
                if random_index == 0:
                    selfie_mutated_chars = chars_selfie[random_index + 1:]
                else:
                    selfie_mutated_chars = chars_selfie[:random_index] + chars_selfie[random_index + 1:]
            else:
                raise Exception('Invalid Operation trying to be performed')

        selfie_mutated = "".join(x for x in selfie_mutated_chars)
        sf = "".join(x for x in chars_selfie)

        try:
            smiles = decoder(selfie_mutated)
            _, smiles_canon, done = sanitize_smiles(smiles)
            if len(selfie_mutated_chars) > max_molecules_len or smiles_canon == "":
                done = False
            if done:
                valid = True
            else:
                valid = False
        except:
            valid = False
            if fail_counter > 1 and write_fail_cases == True:
                f = open("selfie_failure_cases.txt", "a+")
                f.write('Tried to mutate SELFIE: ' + str(sf) + ' To Obtain: ' + str(selfie_mutated) + '\n')
                f.close()

    return selfie_mutated, smiles_canon


def get_selfie_chars(selfie):

    chars_selfie = [] # a list of all SELFIE sybols from string selfie
    while selfie != '':
        chars_selfie.append(selfie[selfie.find('['): selfie.find(']')+1])
        selfie = selfie[selfie.find(']')+1:]
    return chars_selfie

generation_size = 200
num_generations = 30
offspring_size = 100

oracle = OracleStorage()
oracle.assign_evaluator(func)

zinc = MolGen(name = 'ZINC')
all_smiles = zinc.get_data()['smiles'].tolist()

population = np.random.choice(all_smiles, size=generation_size).tolist()
population = [encoder(smi) for smi in population]
len_random_struct = max([len(get_selfie_chars(s)) for s in population])

patience = 0
tournament_size = 15

for gen in trange(num_generations):

    if len(oracle) > 100:
        oracle.sort_buffer()
        old_scores = [item[1][0] for item in list(oracle.mol_buffer.items())[:30]]
    else:
        old_scores = 0

    fitness = oracle([decoder(i) for i in population])

    # step 1: keep the best molecule: keep the best member & mutate the rest
    best_idx = np.argmax(fitness)
    best_selfie = population[best_idx]

    # step 2: get mutated selfies using tournament selection
    new_population = []
    for i in range(generation_size - 1):
        selected_indices = np.random.choice(range(generation_size), size=tournament_size, replace=False)
        tournament_players = [population[idx] for idx in selected_indices]
        tournament_fitness = [fitness[idx] for idx in selected_indices]
        winner_idx = np.argmax(tournament_fitness)
        winner_selfie = tournament_players[winner_idx]

        selfie_mutated, _ = mutate_selfie_diverse(winner_selfie, len_random_struct, write_fail_cases=True)
        new_population.append(selfie_mutated)

    new_population.append(best_selfie)

    # define new population for the next generation
    population = new_population[:]

    # early stopping
    if len(oracle) > 100:
        oracle.sort_buffer()
        new_scores = [item[1][0] for item in list(oracle.mol_buffer.items())[:30]]
        print(f"Generation {gen}: {np.mean(new_scores)}")
        if new_scores == old_scores:
            patience += 1
            if patience >= 5:
                print('Convergence criteria met, abort...')
                break
        else:
            patience = 0

        old_scores = new_scores

oracle.sort_buffer()
np.mean([item[1][0] for item in list(oracle.mol_buffer.items())[:30]])

with open('submission_smiles.txt', 'w') as f:
    for smiles in list(oracle.mol_buffer.keys())[:100]:
        f.write(smiles + '\n')

!cat submission_smiles.txt

top30_submission = pd.DataFrame({
    'smiles': [item[0] for item in list(oracle.mol_buffer.items())[:30]],
    'score': [item[1][0] for item in list(oracle.mol_buffer.items())[:30]],
})

top30_submission

top30_submission.score.mean() + 0.3 * int_div(top30_submission['smiles'].to_list())
